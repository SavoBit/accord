package db

import (
	"encoding/binary"
	"errors"
	"fmt"
	"log"

	"github.com/mistsys/accord/id"
)

type LocalPSKStore struct {
	// pre-shared keys by ID to different environments
	// the id should be checked against the PSK and encrypt
	// the response back
	// This is intended to be used with AES-GCM, where the ID
	// is sent by the server at the beginning of the exchange
	psks map[uint32][]byte
}

func (l *LocalPSKStore) GetPSK(key []byte) ([]byte, error) {
	if len(key) != 4 {
		return nil, errors.New("Key size != 4, cannot lookup the key in local PSK store")
	}
	id := binary.BigEndian.Uint32(key)
	k, ok := l.psks[id]
	if !ok {
		return nil, fmt.Errorf("Cannot lookup key for id: %d", id)
	}
	return k, nil
}

func NewLocalPSKStore(psks map[uint32][]byte) *LocalPSKStore {
	return &LocalPSKStore{
		psks: psks,
	}
}

// LocalDB is for using locally and testing
func NewDummyPSKStore() *LocalPSKStore {
	psks := make(map[uint32][]byte)
	// test = random key generated by
	// < /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c32
	psks[160394189] = []byte(`JpUtbRukLuIFyjeKpA4fIpjgs6MTV8eH`)
	return &LocalPSKStore{
		psks: psks,
	}
}

// This is another easy to use store that can be initialize dwith a single psk
// and a keyId, this is useful for creating client or supplying the psk from
// commandline. This shouldn't be used for production workload.
func NewSinglePSKStore(deploymentId string, salt string, psk string) *LocalPSKStore {
	psks := make(map[uint32][]byte)
	keyId, err := id.KeyID(deploymentId, salt)
	if err != nil {
		log.Printf("Failed to get the keyId: %s", err)
		return nil
	}
	psks[keyId] = []byte(psk)
	return &LocalPSKStore{
		psks: psks,
	}
}
