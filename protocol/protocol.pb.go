// Code generated by protoc-gen-go.
// source: protocol.proto
// DO NOT EDIT!

/*
Package protocol is a generated protocol buffer package.

It is generated from these files:
	protocol.proto

It has these top-level messages:
	PingRequest
	PingResponse
	HostAuthRequest
	Error
	HostAuth
	ReplyMetadata
	HostAuthResponse
	HostCertRequest
	HostCertResponse
	UserAuthRequest
	UserAuthResponse
	UserCertRequest
	OauthToken
	UserCertResponse
	HostCA
	UserCA
	PublicTrustedCARequest
	PublicTrustedCAResponse
*/
package protocol

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type PingRequest struct {
	RequestTime *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=requestTime" json:"requestTime,omitempty"`
	Name        string                     `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
}

func (m *PingRequest) Reset()                    { *m = PingRequest{} }
func (m *PingRequest) String() string            { return proto.CompactTextString(m) }
func (*PingRequest) ProtoMessage()               {}
func (*PingRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PingRequest) GetRequestTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.RequestTime
	}
	return nil
}

func (m *PingRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type PingResponse struct {
	Metadata *ReplyMetadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Message  string         `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *PingResponse) Reset()                    { *m = PingResponse{} }
func (m *PingResponse) String() string            { return proto.CompactTextString(m) }
func (*PingResponse) ProtoMessage()               {}
func (*PingResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *PingResponse) GetMetadata() *ReplyMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *PingResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type HostAuthRequest struct {
	RequestTime *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=requestTime" json:"requestTime,omitempty"`
	// this will be using AES-GCM cipher
	// and include the ID to be the first 4 bytes after concatenating with _ the following
	// the <cloud_name>:<account_id>
	// region
	// environment
	// this is used to identify the preshared key with the cert server
	// in response, the cert server will return an ID that can be used for subsequent cert request
	AuthInfo []byte `protobuf:"bytes,2,opt,name=authInfo,proto3" json:"authInfo,omitempty"`
}

func (m *HostAuthRequest) Reset()                    { *m = HostAuthRequest{} }
func (m *HostAuthRequest) String() string            { return proto.CompactTextString(m) }
func (*HostAuthRequest) ProtoMessage()               {}
func (*HostAuthRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *HostAuthRequest) GetRequestTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.RequestTime
	}
	return nil
}

func (m *HostAuthRequest) GetAuthInfo() []byte {
	if m != nil {
		return m.AuthInfo
	}
	return nil
}

type Error struct {
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	Msg  string `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Error) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Error) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// this is the protobuf message to decrypt the HostAuthResponse.authResponse bytes to
type HostAuth struct {
	Id     []byte   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Errors []*Error `protobuf:"bytes,2,rep,name=errors" json:"errors,omitempty"`
}

func (m *HostAuth) Reset()                    { *m = HostAuth{} }
func (m *HostAuth) String() string            { return proto.CompactTextString(m) }
func (*HostAuth) ProtoMessage()               {}
func (*HostAuth) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *HostAuth) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *HostAuth) GetErrors() []*Error {
	if m != nil {
		return m.Errors
	}
	return nil
}

type ReplyMetadata struct {
	// copies the request time from the client
	RequestTime *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=requestTime" json:"requestTime,omitempty"`
	// when the server initiated the response
	ResponseTime *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=responseTime" json:"responseTime,omitempty"`
}

func (m *ReplyMetadata) Reset()                    { *m = ReplyMetadata{} }
func (m *ReplyMetadata) String() string            { return proto.CompactTextString(m) }
func (*ReplyMetadata) ProtoMessage()               {}
func (*ReplyMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ReplyMetadata) GetRequestTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.RequestTime
	}
	return nil
}

func (m *ReplyMetadata) GetResponseTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.ResponseTime
	}
	return nil
}

type HostAuthResponse struct {
	Metadata *ReplyMetadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// this should be the encrypted response based on the key sent
	// in the authInfo request for the AuthRequest
	// this is expected to contain the encrypted HostAuth message
	AuthResponse []byte `protobuf:"bytes,3,opt,name=authResponse,proto3" json:"authResponse,omitempty"`
}

func (m *HostAuthResponse) Reset()                    { *m = HostAuthResponse{} }
func (m *HostAuthResponse) String() string            { return proto.CompactTextString(m) }
func (*HostAuthResponse) ProtoMessage()               {}
func (*HostAuthResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *HostAuthResponse) GetMetadata() *ReplyMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *HostAuthResponse) GetAuthResponse() []byte {
	if m != nil {
		return m.AuthResponse
	}
	return nil
}

// this is only sent after the host has already authenticated with the server
// someone reasonably can read the ID from memory if an attacker is already root on the host
// but at that point all bets are off..
// we can keep the id and relevant tokens encrypted on disk if we need to persist it
// but since the AuthRequest should've taken care of identifying the machine
// id can be sent over the TLS connection to the server
type HostCertRequest struct {
	RequestTime *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=requestTime" json:"requestTime,omitempty"`
	ValidFrom   *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=validFrom" json:"validFrom,omitempty"`
	ValidUntil  *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=validUntil" json:"validUntil,omitempty"`
	Id          []byte                     `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty"`
	// these need to be FQDN of all the IPs the host needs to have
	Hostnames []string `protobuf:"bytes,5,rep,name=hostnames" json:"hostnames,omitempty"`
	PublicKey []byte   `protobuf:"bytes,6,opt,name=publicKey,proto3" json:"publicKey,omitempty"`
}

func (m *HostCertRequest) Reset()                    { *m = HostCertRequest{} }
func (m *HostCertRequest) String() string            { return proto.CompactTextString(m) }
func (*HostCertRequest) ProtoMessage()               {}
func (*HostCertRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *HostCertRequest) GetRequestTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.RequestTime
	}
	return nil
}

func (m *HostCertRequest) GetValidFrom() *google_protobuf.Timestamp {
	if m != nil {
		return m.ValidFrom
	}
	return nil
}

func (m *HostCertRequest) GetValidUntil() *google_protobuf.Timestamp {
	if m != nil {
		return m.ValidUntil
	}
	return nil
}

func (m *HostCertRequest) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *HostCertRequest) GetHostnames() []string {
	if m != nil {
		return m.Hostnames
	}
	return nil
}

func (m *HostCertRequest) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

type HostCertResponse struct {
	Metadata *ReplyMetadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// this is the cert for the host
	HostCert []byte `protobuf:"bytes,3,opt,name=hostCert,proto3" json:"hostCert,omitempty"`
	// this is the cert the host should "trust" for users
	// logging into the machines
	TrustedUsersCACert []byte `protobuf:"bytes,4,opt,name=trustedUsersCACert,proto3" json:"trustedUsersCACert,omitempty"`
}

func (m *HostCertResponse) Reset()                    { *m = HostCertResponse{} }
func (m *HostCertResponse) String() string            { return proto.CompactTextString(m) }
func (*HostCertResponse) ProtoMessage()               {}
func (*HostCertResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *HostCertResponse) GetMetadata() *ReplyMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *HostCertResponse) GetHostCert() []byte {
	if m != nil {
		return m.HostCert
	}
	return nil
}

func (m *HostCertResponse) GetTrustedUsersCACert() []byte {
	if m != nil {
		return m.TrustedUsersCACert
	}
	return nil
}

type UserAuthRequest struct {
	RequestTime *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=requestTime" json:"requestTime,omitempty"`
	Username    string                     `protobuf:"bytes,2,opt,name=username" json:"username,omitempty"`
	// send the access token
	Token *OauthToken `protobuf:"bytes,4,opt,name=token" json:"token,omitempty"`
}

func (m *UserAuthRequest) Reset()                    { *m = UserAuthRequest{} }
func (m *UserAuthRequest) String() string            { return proto.CompactTextString(m) }
func (*UserAuthRequest) ProtoMessage()               {}
func (*UserAuthRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *UserAuthRequest) GetRequestTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.RequestTime
	}
	return nil
}

func (m *UserAuthRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserAuthRequest) GetToken() *OauthToken {
	if m != nil {
		return m.Token
	}
	return nil
}

type UserAuthResponse struct {
	Metadata     *ReplyMetadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Username     string         `protobuf:"bytes,2,opt,name=username" json:"username,omitempty"`
	Valid        bool           `protobuf:"varint,3,opt,name=valid" json:"valid,omitempty"`
	AuthResponse []byte         `protobuf:"bytes,4,opt,name=authResponse,proto3" json:"authResponse,omitempty"`
}

func (m *UserAuthResponse) Reset()                    { *m = UserAuthResponse{} }
func (m *UserAuthResponse) String() string            { return proto.CompactTextString(m) }
func (*UserAuthResponse) ProtoMessage()               {}
func (*UserAuthResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *UserAuthResponse) GetMetadata() *ReplyMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *UserAuthResponse) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserAuthResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *UserAuthResponse) GetAuthResponse() []byte {
	if m != nil {
		return m.AuthResponse
	}
	return nil
}

type UserCertRequest struct {
	RequestTime *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=requestTime" json:"requestTime,omitempty"`
	Username    string                     `protobuf:"bytes,2,opt,name=username" json:"username,omitempty"`
	// this should go in ID of the cert
	RemoteUsername string `protobuf:"bytes,3,opt,name=remoteUsername" json:"remoteUsername,omitempty"`
	// the raw public key to sign with user cert
	PublicKey []byte `protobuf:"bytes,4,opt,name=publicKey,proto3" json:"publicKey,omitempty"`
	// this is a hack to just respond back with the
	// new principals added to the current cert
	// also it's useful to log before/after for audit
	// once again, never saved by server, just read
	// and discarded...
	// this will be disabled with a future version
	// once the server has a database
	CurrentUserCert      []byte                     `protobuf:"bytes,5,opt,name=currentUserCert,proto3" json:"currentUserCert,omitempty"`
	ValidFrom            *google_protobuf.Timestamp `protobuf:"bytes,6,opt,name=validFrom" json:"validFrom,omitempty"`
	ValidUntil           *google_protobuf.Timestamp `protobuf:"bytes,7,opt,name=validUntil" json:"validUntil,omitempty"`
	AuthorizedPrincipals []string                   `protobuf:"bytes,8,rep,name=authorizedPrincipals" json:"authorizedPrincipals,omitempty"`
	// this should be used for scripts to limit access
	ForceCommands []string `protobuf:"bytes,9,rep,name=forceCommands" json:"forceCommands,omitempty"`
}

func (m *UserCertRequest) Reset()                    { *m = UserCertRequest{} }
func (m *UserCertRequest) String() string            { return proto.CompactTextString(m) }
func (*UserCertRequest) ProtoMessage()               {}
func (*UserCertRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *UserCertRequest) GetRequestTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.RequestTime
	}
	return nil
}

func (m *UserCertRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserCertRequest) GetRemoteUsername() string {
	if m != nil {
		return m.RemoteUsername
	}
	return ""
}

func (m *UserCertRequest) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *UserCertRequest) GetCurrentUserCert() []byte {
	if m != nil {
		return m.CurrentUserCert
	}
	return nil
}

func (m *UserCertRequest) GetValidFrom() *google_protobuf.Timestamp {
	if m != nil {
		return m.ValidFrom
	}
	return nil
}

func (m *UserCertRequest) GetValidUntil() *google_protobuf.Timestamp {
	if m != nil {
		return m.ValidUntil
	}
	return nil
}

func (m *UserCertRequest) GetAuthorizedPrincipals() []string {
	if m != nil {
		return m.AuthorizedPrincipals
	}
	return nil
}

func (m *UserCertRequest) GetForceCommands() []string {
	if m != nil {
		return m.ForceCommands
	}
	return nil
}

type OauthToken struct {
	AccessToken  string                     `protobuf:"bytes,1,opt,name=accessToken" json:"accessToken,omitempty"`
	TokenType    string                     `protobuf:"bytes,2,opt,name=tokenType" json:"tokenType,omitempty"`
	RefreshToken string                     `protobuf:"bytes,3,opt,name=refreshToken" json:"refreshToken,omitempty"`
	Expiry       *google_protobuf.Timestamp `protobuf:"bytes,4,opt,name=expiry" json:"expiry,omitempty"`
}

func (m *OauthToken) Reset()                    { *m = OauthToken{} }
func (m *OauthToken) String() string            { return proto.CompactTextString(m) }
func (*OauthToken) ProtoMessage()               {}
func (*OauthToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *OauthToken) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

func (m *OauthToken) GetTokenType() string {
	if m != nil {
		return m.TokenType
	}
	return ""
}

func (m *OauthToken) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

func (m *OauthToken) GetExpiry() *google_protobuf.Timestamp {
	if m != nil {
		return m.Expiry
	}
	return nil
}

type UserCertResponse struct {
	Metadata       *ReplyMetadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Username       string         `protobuf:"bytes,2,opt,name=username" json:"username,omitempty"`
	UserCert       []byte         `protobuf:"bytes,3,opt,name=userCert,proto3" json:"userCert,omitempty"`
	TrustedHostCAs []*HostCA      `protobuf:"bytes,4,rep,name=trustedHostCAs" json:"trustedHostCAs,omitempty"`
}

func (m *UserCertResponse) Reset()                    { *m = UserCertResponse{} }
func (m *UserCertResponse) String() string            { return proto.CompactTextString(m) }
func (*UserCertResponse) ProtoMessage()               {}
func (*UserCertResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *UserCertResponse) GetMetadata() *ReplyMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *UserCertResponse) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserCertResponse) GetUserCert() []byte {
	if m != nil {
		return m.UserCert
	}
	return nil
}

func (m *UserCertResponse) GetTrustedHostCAs() []*HostCA {
	if m != nil {
		return m.TrustedHostCAs
	}
	return nil
}

// Public Host Certificate Authority's Public Key
// and additional information
// at any given time more than one public CA might
// be trusted, at most 2, so that servers can be
// rotated to new certificates on time
type HostCA struct {
	ValidFrom  *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=validFrom" json:"validFrom,omitempty"`
	ValidUntil *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=validUntil" json:"validUntil,omitempty"`
	PublicKey  []byte                     `protobuf:"bytes,3,opt,name=publicKey,proto3" json:"publicKey,omitempty"`
}

func (m *HostCA) Reset()                    { *m = HostCA{} }
func (m *HostCA) String() string            { return proto.CompactTextString(m) }
func (*HostCA) ProtoMessage()               {}
func (*HostCA) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *HostCA) GetValidFrom() *google_protobuf.Timestamp {
	if m != nil {
		return m.ValidFrom
	}
	return nil
}

func (m *HostCA) GetValidUntil() *google_protobuf.Timestamp {
	if m != nil {
		return m.ValidUntil
	}
	return nil
}

func (m *HostCA) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

type UserCA struct {
	ValidFrom  *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=validFrom" json:"validFrom,omitempty"`
	ValidUntil *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=validUntil" json:"validUntil,omitempty"`
	PublicKey  []byte                     `protobuf:"bytes,3,opt,name=publicKey,proto3" json:"publicKey,omitempty"`
}

func (m *UserCA) Reset()                    { *m = UserCA{} }
func (m *UserCA) String() string            { return proto.CompactTextString(m) }
func (*UserCA) ProtoMessage()               {}
func (*UserCA) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *UserCA) GetValidFrom() *google_protobuf.Timestamp {
	if m != nil {
		return m.ValidFrom
	}
	return nil
}

func (m *UserCA) GetValidUntil() *google_protobuf.Timestamp {
	if m != nil {
		return m.ValidUntil
	}
	return nil
}

func (m *UserCA) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

// I may add more parameters for logging in future
type PublicTrustedCARequest struct {
	RequestTime *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=requestTime" json:"requestTime,omitempty"`
}

func (m *PublicTrustedCARequest) Reset()                    { *m = PublicTrustedCARequest{} }
func (m *PublicTrustedCARequest) String() string            { return proto.CompactTextString(m) }
func (*PublicTrustedCARequest) ProtoMessage()               {}
func (*PublicTrustedCARequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *PublicTrustedCARequest) GetRequestTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.RequestTime
	}
	return nil
}

type PublicTrustedCAResponse struct {
	Metadata *ReplyMetadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	HostCAs  []*HostCA      `protobuf:"bytes,2,rep,name=hostCAs" json:"hostCAs,omitempty"`
	UserCAs  []*UserCA      `protobuf:"bytes,3,rep,name=UserCAs" json:"UserCAs,omitempty"`
	// the clients should update their corresponding
	// revoked CA file with the contents
	RevokedHostCAs []*HostCA `protobuf:"bytes,4,rep,name=revokedHostCAs" json:"revokedHostCAs,omitempty"`
	RevokedUserCAs []*UserCA `protobuf:"bytes,5,rep,name=revokedUserCAs" json:"revokedUserCAs,omitempty"`
}

func (m *PublicTrustedCAResponse) Reset()                    { *m = PublicTrustedCAResponse{} }
func (m *PublicTrustedCAResponse) String() string            { return proto.CompactTextString(m) }
func (*PublicTrustedCAResponse) ProtoMessage()               {}
func (*PublicTrustedCAResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *PublicTrustedCAResponse) GetMetadata() *ReplyMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *PublicTrustedCAResponse) GetHostCAs() []*HostCA {
	if m != nil {
		return m.HostCAs
	}
	return nil
}

func (m *PublicTrustedCAResponse) GetUserCAs() []*UserCA {
	if m != nil {
		return m.UserCAs
	}
	return nil
}

func (m *PublicTrustedCAResponse) GetRevokedHostCAs() []*HostCA {
	if m != nil {
		return m.RevokedHostCAs
	}
	return nil
}

func (m *PublicTrustedCAResponse) GetRevokedUserCAs() []*UserCA {
	if m != nil {
		return m.RevokedUserCAs
	}
	return nil
}

func init() {
	proto.RegisterType((*PingRequest)(nil), "protocol.PingRequest")
	proto.RegisterType((*PingResponse)(nil), "protocol.PingResponse")
	proto.RegisterType((*HostAuthRequest)(nil), "protocol.HostAuthRequest")
	proto.RegisterType((*Error)(nil), "protocol.Error")
	proto.RegisterType((*HostAuth)(nil), "protocol.HostAuth")
	proto.RegisterType((*ReplyMetadata)(nil), "protocol.ReplyMetadata")
	proto.RegisterType((*HostAuthResponse)(nil), "protocol.HostAuthResponse")
	proto.RegisterType((*HostCertRequest)(nil), "protocol.HostCertRequest")
	proto.RegisterType((*HostCertResponse)(nil), "protocol.HostCertResponse")
	proto.RegisterType((*UserAuthRequest)(nil), "protocol.UserAuthRequest")
	proto.RegisterType((*UserAuthResponse)(nil), "protocol.UserAuthResponse")
	proto.RegisterType((*UserCertRequest)(nil), "protocol.UserCertRequest")
	proto.RegisterType((*OauthToken)(nil), "protocol.OauthToken")
	proto.RegisterType((*UserCertResponse)(nil), "protocol.UserCertResponse")
	proto.RegisterType((*HostCA)(nil), "protocol.HostCA")
	proto.RegisterType((*UserCA)(nil), "protocol.UserCA")
	proto.RegisterType((*PublicTrustedCARequest)(nil), "protocol.PublicTrustedCARequest")
	proto.RegisterType((*PublicTrustedCAResponse)(nil), "protocol.PublicTrustedCAResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Cert service

type CertClient interface {
	HostAuth(ctx context.Context, in *HostAuthRequest, opts ...grpc.CallOption) (*HostAuthResponse, error)
	HostCert(ctx context.Context, in *HostCertRequest, opts ...grpc.CallOption) (*HostCertResponse, error)
	UserAuth(ctx context.Context, in *UserAuthRequest, opts ...grpc.CallOption) (*UserAuthResponse, error)
	UserCert(ctx context.Context, in *UserCertRequest, opts ...grpc.CallOption) (*UserCertResponse, error)
	// This responds back with both host CAs that the users should trust
	// and the user CA the servers should trust
	PublicTrustedCA(ctx context.Context, in *PublicTrustedCARequest, opts ...grpc.CallOption) (*PublicTrustedCAResponse, error)
	// this is just for test/sanity
	// We may report he metric to get a sense of how the latency between
	// environments is faring
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
}

type certClient struct {
	cc *grpc.ClientConn
}

func NewCertClient(cc *grpc.ClientConn) CertClient {
	return &certClient{cc}
}

func (c *certClient) HostAuth(ctx context.Context, in *HostAuthRequest, opts ...grpc.CallOption) (*HostAuthResponse, error) {
	out := new(HostAuthResponse)
	err := grpc.Invoke(ctx, "/protocol.Cert/HostAuth", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certClient) HostCert(ctx context.Context, in *HostCertRequest, opts ...grpc.CallOption) (*HostCertResponse, error) {
	out := new(HostCertResponse)
	err := grpc.Invoke(ctx, "/protocol.Cert/HostCert", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certClient) UserAuth(ctx context.Context, in *UserAuthRequest, opts ...grpc.CallOption) (*UserAuthResponse, error) {
	out := new(UserAuthResponse)
	err := grpc.Invoke(ctx, "/protocol.Cert/UserAuth", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certClient) UserCert(ctx context.Context, in *UserCertRequest, opts ...grpc.CallOption) (*UserCertResponse, error) {
	out := new(UserCertResponse)
	err := grpc.Invoke(ctx, "/protocol.Cert/UserCert", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certClient) PublicTrustedCA(ctx context.Context, in *PublicTrustedCARequest, opts ...grpc.CallOption) (*PublicTrustedCAResponse, error) {
	out := new(PublicTrustedCAResponse)
	err := grpc.Invoke(ctx, "/protocol.Cert/PublicTrustedCA", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	out := new(PingResponse)
	err := grpc.Invoke(ctx, "/protocol.Cert/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Cert service

type CertServer interface {
	HostAuth(context.Context, *HostAuthRequest) (*HostAuthResponse, error)
	HostCert(context.Context, *HostCertRequest) (*HostCertResponse, error)
	UserAuth(context.Context, *UserAuthRequest) (*UserAuthResponse, error)
	UserCert(context.Context, *UserCertRequest) (*UserCertResponse, error)
	// This responds back with both host CAs that the users should trust
	// and the user CA the servers should trust
	PublicTrustedCA(context.Context, *PublicTrustedCARequest) (*PublicTrustedCAResponse, error)
	// this is just for test/sanity
	// We may report he metric to get a sense of how the latency between
	// environments is faring
	Ping(context.Context, *PingRequest) (*PingResponse, error)
}

func RegisterCertServer(s *grpc.Server, srv CertServer) {
	s.RegisterService(&_Cert_serviceDesc, srv)
}

func _Cert_HostAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertServer).HostAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.Cert/HostAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertServer).HostAuth(ctx, req.(*HostAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cert_HostCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertServer).HostCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.Cert/HostCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertServer).HostCert(ctx, req.(*HostCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cert_UserAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertServer).UserAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.Cert/UserAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertServer).UserAuth(ctx, req.(*UserAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cert_UserCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertServer).UserCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.Cert/UserCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertServer).UserCert(ctx, req.(*UserCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cert_PublicTrustedCA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicTrustedCARequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertServer).PublicTrustedCA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.Cert/PublicTrustedCA",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertServer).PublicTrustedCA(ctx, req.(*PublicTrustedCARequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cert_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.Cert/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Cert_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protocol.Cert",
	HandlerType: (*CertServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HostAuth",
			Handler:    _Cert_HostAuth_Handler,
		},
		{
			MethodName: "HostCert",
			Handler:    _Cert_HostCert_Handler,
		},
		{
			MethodName: "UserAuth",
			Handler:    _Cert_UserAuth_Handler,
		},
		{
			MethodName: "UserCert",
			Handler:    _Cert_UserCert_Handler,
		},
		{
			MethodName: "PublicTrustedCA",
			Handler:    _Cert_PublicTrustedCA_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Cert_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protocol.proto",
}

func init() { proto.RegisterFile("protocol.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 923 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xdd, 0x8a, 0x23, 0x45,
	0x14, 0xb6, 0xbb, 0x93, 0x4c, 0x72, 0x92, 0x9d, 0x0c, 0xc5, 0xb8, 0xdb, 0x06, 0xc1, 0x58, 0xf8,
	0x13, 0x16, 0xcc, 0x42, 0xf6, 0x42, 0x11, 0x11, 0xb2, 0x41, 0x51, 0x44, 0x1c, 0x9a, 0x8c, 0x78,
	0x23, 0xd2, 0xd3, 0xa9, 0x49, 0x9a, 0x49, 0x77, 0xb5, 0x55, 0xd5, 0x8b, 0xe3, 0x3b, 0x78, 0x21,
	0x5e, 0x08, 0xa2, 0x77, 0xde, 0x89, 0x0f, 0xe0, 0xdb, 0x49, 0xfd, 0xf4, 0x5f, 0x6d, 0x26, 0xee,
	0x6e, 0x72, 0xe1, 0x5d, 0x9f, 0x73, 0xbe, 0xfa, 0xea, 0xd4, 0x39, 0x5f, 0xd5, 0x49, 0xe0, 0x34,
	0x63, 0x54, 0xd0, 0x88, 0x6e, 0xa7, 0xea, 0x03, 0x75, 0x0b, 0x7b, 0xf4, 0xc6, 0x9a, 0xd2, 0xf5,
	0x96, 0x3c, 0x52, 0x8e, 0xab, 0xfc, 0xfa, 0x91, 0x88, 0x13, 0xc2, 0x45, 0x98, 0x64, 0x1a, 0x8a,
	0xbf, 0x83, 0xfe, 0x45, 0x9c, 0xae, 0x03, 0xf2, 0x7d, 0x4e, 0xb8, 0x40, 0x1f, 0x41, 0x9f, 0xe9,
	0xcf, 0x65, 0x9c, 0x10, 0xdf, 0x19, 0x3b, 0x93, 0xfe, 0x6c, 0x34, 0xd5, 0x2c, 0xd3, 0x82, 0x65,
	0xba, 0x2c, 0x58, 0x82, 0x3a, 0x1c, 0x21, 0x68, 0xa5, 0x61, 0x42, 0x7c, 0x77, 0xec, 0x4c, 0x7a,
	0x81, 0xfa, 0xc6, 0xdf, 0xc2, 0x40, 0x6f, 0xc0, 0x33, 0x9a, 0x72, 0x82, 0x1e, 0x43, 0x37, 0x21,
	0x22, 0x5c, 0x85, 0x22, 0x34, 0xf4, 0x0f, 0xa6, 0x65, 0xfa, 0x01, 0xc9, 0xb6, 0xb7, 0x5f, 0x9a,
	0x70, 0x50, 0x02, 0x91, 0x0f, 0x27, 0x09, 0xe1, 0x3c, 0x5c, 0x17, 0xdc, 0x85, 0x89, 0x6f, 0x60,
	0xf8, 0x19, 0xe5, 0x62, 0x9e, 0x8b, 0xcd, 0x71, 0xce, 0x30, 0x82, 0x6e, 0x98, 0x8b, 0xcd, 0xe7,
	0xe9, 0x35, 0x55, 0x7b, 0x0d, 0x82, 0xd2, 0xc6, 0xef, 0x41, 0xfb, 0x13, 0xc6, 0x28, 0x93, 0x07,
	0x15, 0xb7, 0x99, 0xe6, 0xee, 0x05, 0xea, 0x1b, 0x9d, 0x81, 0x97, 0xf0, 0xb5, 0xc9, 0x4f, 0x7e,
	0xe2, 0x05, 0x74, 0x8b, 0xdc, 0xd0, 0x29, 0xb8, 0xf1, 0x4a, 0xe1, 0x07, 0x81, 0x1b, 0xaf, 0xd0,
	0xbb, 0xd0, 0x21, 0x92, 0x8a, 0xfb, 0xee, 0xd8, 0x9b, 0xf4, 0x67, 0xc3, 0xaa, 0x08, 0x6a, 0x8b,
	0xc0, 0x84, 0xf1, 0x4f, 0x0e, 0xdc, 0x6b, 0x94, 0xe5, 0xc0, 0xf3, 0x7d, 0x0c, 0x03, 0x66, 0x7a,
	0xa1, 0x96, 0xbb, 0xff, 0xb9, 0xbc, 0x81, 0xc7, 0x37, 0x70, 0x56, 0x15, 0xfc, 0x90, 0x9e, 0x62,
	0x18, 0x84, 0x35, 0x12, 0xdf, 0x53, 0xb5, 0x69, 0xf8, 0xf0, 0xcf, 0xae, 0x6e, 0xef, 0x82, 0x30,
	0x71, 0x9c, 0xf6, 0x7e, 0x00, 0xbd, 0xa7, 0xe1, 0x36, 0x5e, 0x7d, 0xca, 0x68, 0xf2, 0x1c, 0x67,
	0xaf, 0xc0, 0xe8, 0x43, 0x00, 0x65, 0x5c, 0xa6, 0x22, 0xde, 0xaa, 0x6c, 0xf7, 0x2f, 0xad, 0xa1,
	0x4d, 0xf7, 0x5b, 0x65, 0xf7, 0x5f, 0x87, 0xde, 0x86, 0x72, 0x21, 0x2f, 0x08, 0xf7, 0xdb, 0x63,
	0x6f, 0xd2, 0x0b, 0x2a, 0x87, 0x8c, 0x66, 0xf9, 0xd5, 0x36, 0x8e, 0xbe, 0x20, 0xb7, 0x7e, 0x47,
	0x2d, 0xaa, 0x1c, 0xf8, 0x17, 0x47, 0x77, 0x40, 0xd7, 0xe4, 0x90, 0x0e, 0x8c, 0xa0, 0xbb, 0x31,
	0x44, 0xa6, 0xfa, 0xa5, 0x8d, 0xa6, 0x80, 0x04, 0xcb, 0xb9, 0x20, 0xab, 0x4b, 0x4e, 0x18, 0x5f,
	0xcc, 0x15, 0x4a, 0x9f, 0x60, 0x47, 0x04, 0xff, 0xea, 0xc0, 0x50, 0xda, 0x47, 0xbd, 0x88, 0x39,
	0x27, 0xac, 0xf6, 0xa0, 0x94, 0x36, 0x7a, 0x08, 0x6d, 0x41, 0x6f, 0x48, 0xaa, 0x12, 0xea, 0xcf,
	0xce, 0xab, 0xb3, 0x7e, 0x25, 0xf5, 0xb3, 0x94, 0xb1, 0x40, 0x43, 0xf0, 0x1f, 0x0e, 0x9c, 0x55,
	0x99, 0x1d, 0x58, 0xaf, 0x3b, 0x33, 0x3a, 0x87, 0xb6, 0xea, 0xb7, 0x2a, 0x64, 0x37, 0xd0, 0xc6,
	0x33, 0x1a, 0x6f, 0xed, 0xd0, 0xf8, 0x5f, 0x9e, 0xae, 0xdc, 0xf1, 0x34, 0xbe, 0x2f, 0xcf, 0x77,
	0xe0, 0x94, 0x91, 0x84, 0x0a, 0x72, 0x59, 0x20, 0x3c, 0x85, 0xb0, 0xbc, 0x4d, 0x0d, 0xb6, 0x2c,
	0x0d, 0xa2, 0x09, 0x0c, 0xa3, 0x9c, 0x31, 0x92, 0x8a, 0x22, 0x73, 0xbf, 0xad, 0x30, 0xb6, 0xbb,
	0x79, 0xdf, 0x3a, 0x2f, 0x7f, 0xdf, 0x4e, 0x5e, 0xe8, 0xbe, 0xcd, 0xe0, 0x5c, 0xd6, 0x98, 0xb2,
	0xf8, 0x47, 0xb2, 0xba, 0x60, 0x71, 0x1a, 0xc5, 0x59, 0xb8, 0xe5, 0x7e, 0x57, 0x5d, 0xb5, 0x9d,
	0x31, 0xf4, 0x16, 0xdc, 0xbb, 0xa6, 0x2c, 0x22, 0x0b, 0x9a, 0x24, 0x61, 0xba, 0xe2, 0x7e, 0x4f,
	0x81, 0x9b, 0x4e, 0xfc, 0xa7, 0x03, 0x50, 0x69, 0x0c, 0x8d, 0xa1, 0x1f, 0x46, 0x11, 0xe1, 0x5c,
	0x99, 0x66, 0x1e, 0xd4, 0x5d, 0xb2, 0x90, 0x4a, 0x87, 0x4b, 0x39, 0x2f, 0x74, 0x37, 0x2a, 0x87,
	0x14, 0x08, 0x23, 0xd7, 0x8c, 0x70, 0xcd, 0x67, 0x9a, 0xd1, 0xf0, 0xa1, 0x19, 0x74, 0xc8, 0x0f,
	0x59, 0xcc, 0x6e, 0x8d, 0xda, 0xf7, 0x15, 0xc1, 0x20, 0xf1, 0x3f, 0x46, 0xf4, 0x47, 0x79, 0x24,
	0xee, 0x14, 0x93, 0x89, 0xd5, 0x1f, 0x90, 0xbc, 0x6a, 0xfc, 0xa9, 0x79, 0x26, 0xd4, 0x63, 0x35,
	0xe7, 0x7e, 0x4b, 0x0d, 0xba, 0xb3, 0x6a, 0x4b, 0x1d, 0x08, 0x2c, 0x1c, 0xfe, 0xdd, 0x81, 0x8e,
	0xfe, 0x6e, 0xaa, 0xc7, 0x79, 0x79, 0xf5, 0xb8, 0x2f, 0xa4, 0x9e, 0x86, 0xf6, 0x3d, 0xfb, 0xfd,
	0x95, 0xe9, 0xa9, 0xd2, 0xfe, 0x3f, 0xd3, 0xfb, 0x1a, 0xee, 0x5f, 0x28, 0x63, 0xa9, 0xab, 0xba,
	0x98, 0x1f, 0xe5, 0x51, 0xc1, 0xbf, 0xb9, 0xf0, 0xe0, 0x19, 0xe2, 0x43, 0x84, 0xf5, 0x10, 0x4e,
	0x36, 0x46, 0x19, 0xee, 0x1d, 0xca, 0x28, 0x00, 0x12, 0xab, 0x4b, 0xce, 0x7d, 0xcf, 0xc6, 0xea,
	0x40, 0x50, 0x00, 0xa4, 0xf0, 0x18, 0x79, 0x4a, 0x6f, 0x9e, 0x43, 0x78, 0x4d, 0x5c, 0x6d, 0x65,
	0xb1, 0x59, 0xfb, 0x8e, 0xcd, 0x2c, 0xdc, 0xec, 0x6f, 0x0f, 0x5a, 0x4a, 0xf5, 0xf5, 0x9f, 0x7c,
	0xaf, 0x35, 0x37, 0xac, 0x4d, 0xc6, 0xd1, 0x68, 0x57, 0xc8, 0xcc, 0x83, 0x57, 0x0a, 0x12, 0x45,
	0x68, 0x91, 0xd4, 0x86, 0x84, 0x4d, 0x52, 0xbf, 0xea, 0x9a, 0xa4, 0x98, 0x7a, 0x75, 0x12, 0x6b,
	0x46, 0xd7, 0x49, 0xec, 0x21, 0x59, 0x91, 0xd8, 0x99, 0x58, 0xe3, 0xca, 0x26, 0xb1, 0x32, 0xf9,
	0x06, 0x86, 0x96, 0x70, 0xd0, 0xb8, 0x5a, 0xb0, 0x5b, 0xac, 0xa3, 0x37, 0xf7, 0x20, 0x4a, 0xe6,
	0xf7, 0xa1, 0x25, 0xff, 0x5b, 0xa0, 0x57, 0x6b, 0xe0, 0xea, 0xcf, 0xcc, 0xe8, 0xbe, 0xed, 0x2e,
	0x16, 0x3e, 0x79, 0x1b, 0xfc, 0x88, 0x26, 0xd3, 0x24, 0xe6, 0x62, 0x1a, 0x46, 0x11, 0x65, 0xab,
	0x12, 0xfa, 0xe4, 0x64, 0x1e, 0x29, 0xcf, 0x85, 0x73, 0xd5, 0x51, 0xce, 0xc7, 0xff, 0x06, 0x00,
	0x00, 0xff, 0xff, 0x62, 0x47, 0x19, 0xe2, 0x60, 0x0d, 0x00, 0x00,
}
